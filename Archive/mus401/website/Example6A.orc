sr=22050kr=2205ksmps=10nchnls=1instr 8 ; Csound realization a Frequency Modulation Trumpetiamp = p4 * 25000 ;Amplitude of the first carrier.iamp2 = iamp * .2 ;Amplitude of the second carrier. It is the second carrier                        ;which will simulate the formant.ifundfreq = p5 ;The fundemental frequency, used to calculate the frequencies of                ;both carrier oscillators as well as the modulating oscillator.;The equation below is a standard way of calculating a value for frequency;which will be as near to a formant frequency as possible while also;being a harmonic partial of the fundamental. The important formant;for the trumpet is approximately 1500 Hz. Therefore we want to have an;increase in energy near that frequency to simulate the formant in order;to synthesize a trumpet-like sound. To do that we will use a second carrier;oscillator with a frequency corresponding to the formant. The trumpet is an;instrument with harmomic partials so the formant must also be a harmonic.;For example, suppose the fundamental frequency were 440Hz. It is easy to see;that 1500Hz is not a harmonic partial of 440Hz (1500 is not an integer;multiple of 440). If we put 440 into the equation:;;        iformant = int((1500/440) + .5) * 440,;;we get a result of 1320 for iformant. The "int" function returns the integer;portion (the number to the left of the decimal point) of a mathematical;expression. So int(1500/440) would return 3 instead of 3.409.;We do this because we want to multiply the fundamental by an integer to;get a frequency that will be a harmonic partial. .5 is added to the result;of the division before taking the "int" of the expression to ensure better;rounding. So,;;       int((formant/fundemtal) + .5);;gives us an integer which will be the number of the harmonic closest to;the formant. We then multiply the fundemental by that integer to get the;value of that harmonic in Hz as was done above to get 1320Hz. It might;help you understand this better if you insert your own values for;fundamentals and formants and do the calculations to see the results!iformant = int((1500/ifundfreq + .5)) * ifundfreq;The variable "idev1" is the deviation, or amplitude of the the modulating;oscillator. "p6" is an index-like scalar set in the score to make the sound;more or less bright.idev1   = (ifundfreq * 3) * p6;The variable "idev2" will be used to scale the output of the modulator;before being used by the second carrier. Because we don't want to create;as many side bands around the second carrier (the formant), the deviation;should be smaller.idev2   = .666 * p6; VIBRATOarand   randi   .007, 15kvibamp oscil1  0, .007, p3, 2                ;f2 0 4097 9 .5 1 0 (Half a period of a sine wave)avibosc oscil   kvibamp, 5, 1aporta  linseg  0, .06, .03, p3-.06, .02avib    =       (1+arand) * (1+avibosc) * (1+aporta);ENVELOPES (see Csound Manual for description of "envlpx"        ;This envelope generator will be covered in class too, so        ;don't worry if you find it confusing at first!).aenv1   envlpx  1, .1, p3, .15, 3, .9, .01aenv2   envlpx  1, .1, p3, .01, 3, .9, .01aenv3   envlpx  1, .1, p3, .3, 3, .9, .01;MODULATORamod    oscili idev1*aenv2, ifundfreq*avib, 1;CARRIER1acar1   oscili aenv1*iamp, (ifundfreq*avib)+amod, 1;Scale down the output of the modulatoramod2 = amod * idev2;CARRIER2acar2   oscili iamp2*aenv3, (iformant*avib) + amod2, 1asig = acar1 + acar2out asigendin