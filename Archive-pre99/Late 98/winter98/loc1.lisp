(in-package :stella)
;
(defobject one (csound-note)
  ((instr :initform "i1") dur amp freq pct deg dist)
  (:parameters instr time dur amp freq pct deg dist))
;
(defobject two (csound-note)
  ((instr :initform "i2") dur amp car modrat index degree dist spdsca revpct distend enddeg mxfrq)
  (:parameters instr time dur amp car modrat index degree dist spdsca revpct distend enddeg mxfrq))
(defobject three (csound-note)
  ((instr :initform "i3") dur amp freq pct deg dist)
  (:parameters instr time dur amp freq pct deg dist))
;
(defobject reverb (csound-note)
  ((name :initform "i99") mystart dur revtime)
  (:parameters name mystart dur revtime))
;
(defparameter *totaldur* 0)
;
(defun note1 (mystart num)
  (algorithm nil two (start mystart length num)
	(setf rhythm (between 1 3)) 
	(setf dur (* rhythm 3))
	(setf amp 15000)
	(setf car (item (pitches a6 e6 a6 e6 a7 e7 a8 e8 fs7 fs8 fs9 in heap)))
	(setf modrat (between 1.5 3.8))
	(setf index (between 1 3))
	(setf degree (between 0 90))
	(setf enddeg (between 0 90))
	(setf dist (between 1 1.5))
	(setf distend (between 10 100))
	(setf spdsca 1)
	(setf revpct .05)
	(setf mxfrq (* (* car modrat) index))
	(setf *totaldur* (max (+ time dur) *totaldur*))
    ))
;
(defun note2 (mystart num)
  (algorithm nil two (start mystart length num)
	(setf rhythm (item (rhythms e e e e e e e. e. e. q q q. in heap tempo(tempo 400))))
	(setf dur (* rhythm 30))
	(setf amp 10000)
	(setf car (item (items 55 110 165 in heap)))
	(setf modrat (item (items 1 2 3 4 1 2 3 1 2 1 in heap)))
	(setf index (item (items 1 2 3 4 1 2 3 1 2 1 in heap)))
	(setf degree (between 0 90))
	(setf enddeg (between 0 90))
	(setf dist (between 1 1.5))
	(setf distend (between 10 50))
	(setf spdsca (* dur 10))
	(setf revpct .05)
	(setf mxfrq (* (* car modrat) index))
	(setf *totaldur* (max (+ time dur) *totaldur*))
    ))
;
(defun plunk (mystart num distance)
  (algorithm nil one (start mystart length num)
	     (setf rhythm .05)
	     (setf dur rhythm)
	     (setf amp (interpl count 0 1000.0 200 10000.0))
	     (setf freq (interpl count 0 110.0 200 220.0))
	     (setf pct (between .05 .1))
	     (setf deg (interpl count 0 0.0 200 90.0))
	     (setf dist distance)
	     (setf *totaldur* (max (+ time dur) *totaldur*))
))
;
(defun plink (mystart num distance)
  (algorithm nil three (start mystart length num)
	     (setf rhythm .05)
	     (setf dur (* 2 rhythm))
	     (setf amp (interpl count 0 100.0 200 10000.0))
	     (setf freq (interpl count 0 1100.0 200 2200.0))
	     (setf pct .5)
	     (setf deg (interpl count 0 90.0 200 0.0))
	     (setf dist distance)
	     (setf *totaldur* (max (+ time dur) *totaldur*))	     
))
;
(defun make-rev-note (&key (revtime 2.5))
  (algorithm nil reverb (start 10000 length 1 revtime revtime rhythm 0)
    (setf mystart 1)
    (setf dur (+ revtime *totaldur*))
    ))
;


;

;
(defun m-s (&key (start-time 1.)(my-scorefile "loc2.sco"))
  (let* ((myheader (header "f 1 0 16384 10 1"
			   "f 2 0 1024 1 \"angle.aiff\" 0 0 1"
			   "f 3 0 16385 5 1 16384 .001")))
    (fheader my-scorefile myheader)
    (merge all ()
	   (note1 1 1)
	   (note2 4 60)
	   (note1 15 6)
	   (note2 20 75)
	   (plink 30 200 30.0)
	   (plink 35 200 100.0)
	   (plink 40 200 150.0)
	   (plink 45 200 200.0)
	   (note1 55 3)
	   (note2 55 10)
	   (plunk 55 50 1)
	   (plunk 60 1 10.0)
	   (note1 60 1)
	   (plunk 62 1 100.0)
	   (note1 62 1)
	   (plunk 64 10 300)
	   (make-rev-note)
)
    (write-cs "all" :filename my-scorefile)))
