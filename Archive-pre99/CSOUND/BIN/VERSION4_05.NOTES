Release Notes for 4.05
======================

These are the release notes for version 4.05.  There were no notes for
4.04 which was only released for Linux.  This version contains two new
families of opcodes, and some significant fixes. 

Bug Fixes
---------

Calculation of kr (if omitted) was wrong

On some systems (notable recent Linux) the double closing of the file
scfp let to crashes.

Temporary files are cleaned up in more circumstances

Problems with large numbers of labels fixed


Language Changes
----------------

Added a new option, -Z, which switches on dithering of audio
conversion from internal fpt to 32bit, 16bit and 8bit formats.  This
is not properly tested


Opcode Fixes
------------

atone and atonex failed if the input and output were the same variable

Simpler tests in midiops3 family


New Opcodes 
-----------
Added two opcodes for scanned synthesis (Interval's copyright):
        scanu
        scans

Added family of Sound Font opcodes:
        sfload, sfpreset, sfplay, sfplaym, 
        sfplist, sfilist, sfpassign, sfinstrm, sfinstr

Other Changes:
-------------

Integration of BeOs makefiles and audio

Windows GUI Changes
-------------------

None

------------------------------------------------------------------------
==John ff
  2000 March 
========================================================================
SoundFont2-related opcodes

ifilhandle sfload "filename" 
           sfplist ifilhandle
           sfilist ifilhandle
           sfpassign istartindex, ifilhandle
ipreindex  sfpreset iprog, ibank, ifilhandle, ipreindex

a1, a2     sfplay ivel, inotnum, xamp, xfreq, ipreindex [, iflag]
a1         sfplaym ivel, inotnum, xamp, xfreq, ipreindex [, iflag]

a1, a2     sfinstr ivel, inotnum, xamp, xfreq, instrNum, ifilhandle [, iflag]
a1         sfinstrm ivel, inotnum, xamp, xfreq, instrNum, ifilhandle [, iflag]

DESCRIPTION

Csound now supports SoundFont2 format. These opcodes allow to manage
the sample-structure of SoundFont2 files.

INITIALIZATION

filename - name of the SoundFont2 file (complete pathname). You must
use "/" to separate directories even under Windows. It must be typed within
double-quotes.
ifilhandle - unique number generated by sfload opcode to be used as
an identifier of a SoundFont2 file, since several SoundFont2 files can be
loaded and activated at the same time.
istartindex - starting preset index set by the user in bulk preset
assignments (see below).
ipreindex - preset index 
iprog - program number of a bank of presets of a SoundFont2 file
ibank - number of a specific bank of a SoundFont2 file
ivel - velocity value
inotnum - note number value
iflag - flag regarding the behaviour of xfreq (see below).
instrNum - number of an instrument of a SoundFont2 file.

PERFORMANCE

xamp - amplitude correction factor
xfreq - frequency value or frequency correction factor (depending
by iflag, see below)


SoundFont2 is a widespread standard which allow to embed banks of wavetable-based
sounds into a binary file. In order to understand the usage of these opcodes,
the user must know some notion about SF2 format. So a brief description of
this format follows.

The SoundFont2 format is made by generator and modulator objects. All
current Csound opcodes regarding SF2 support generator section only,
so we will only deal with the generator-related structure of SF2
format, omitting the modulators. 

There are several levels of generators having a hierarchical
structure. The most basic kind of generator object is a
sample. Samples can or can't be be looped and are associated to a MIDI
note number, called base-key. When a sample is associated with a range
of MIDI note numbers, with a range of velocities, with a transposition
(coarse and fine tuning), with a scale tuning, and with a level
scaling factor, such sample makes up a split. A set of splits,
together with a name, makes up an instrument. When an instrument is
associated with a key range, with a velocity range, with a level
scaling factor, and with a transposition, it makes up a layer. A
set of layers, together with a name, makes up a preset. Presets are
normally the final sound-generating structures ready for the
user. They generate sound according to the settings of their
lower-level components.

Both sample data and structure data is embedded in the same SoundFont2
binary file. A single SF2 file can contain up to a maximum of 128
banks of 128 preset programs, for a total of 16384 presets each
one. Maximum number of layers, instruments, splits and samples is not
defined, and probably is only limited by the computer memory.

sfload opcode loads an entire SF2 file in memory. It returns a file
handle to be used by other opcodes. Several instances of sfload can
placed in the header section of an orchestra, allowing to work with
more-than-one SF2 files at the same time.

sfplist prints a list of all presets of a previously loaded SF2 file
to the console.

sfilist prints a list of all instruments of a previously loaded SF2
file to the console.

sfpassign assigns all presets of a previously loaded SF2 file to a
sequence of progressive index numbers, to be used later with the
opcodes sfplay and sfplaym. The user can establish the first index
number by setting startindex argument. Any number of sfpassign
instances can be placed in the header section of an orchestra, each
one assigning presets belonging to different SF2 files. The user must
take care that preset index numbers of different SF2 files don't cross
themselves.

sfpreset assigns an existing preset of a previously-loaded SF2 file to
an index number, to be used later with the opcodes sfplay and
sfplaym. The user must previously know the program and the bank
numbers of the preset in order to fill the corresponding
arguments. Any number of sfpreset instances can be placed in the
header section of an orchestra, each one assigning a different preset
belonging to the same (or different) SF2 file to different index
numbers.

sfplay plays a preset generating a stereo sound.
ivel argument does not directly affect the amplitude of the output,
but inform sfplay opcode about what sample has to be chosen in
multi-sample velocity-splitted presets. inotnum argument sets
the frequency of the output when iflag = 0. When iflag == 1, inotnum
doesn't directly affect the frequency of the output (see
below). Adjustment of amplitude can be done by varying the xamp
argument, that actually is a multiplier factor. xfreq argument have a
two different behaviour depending by the value of iflag argument:

    when iflag = 0 (or missing as this value is the default)
    xfreq argument is a multiplier of a the default frequency
    assigned by SF2 preset to the inotenum value. This can correct
    the default frequency (for example to obtain vibrato or some other
    frequency -shift effect).

    when iflag = 1 xfreq argument should contain
    the actual frequency of the output sound in cps. This allow the
    user to use any kind of micro-tuning based scales. However this
    flag is designed to work correctly only with presets tuned to the
    default equal temperament. Don't try to use this flag value with
    preset already having non-standard tunings or with drum-kit-based
    presets, since unexpected results could occur. 


Notice that both xamp and xfreq arguments can contain k-rate signals
as well as a-rate signals, but the user must be sure that both
arguments are filled with variables of the same rate, or sfplay will
not work correctly.  The user must be sure that ipreindex argument is
filled with a number containing a previously assigned preset,
otherwise Csound will crash.

sfplaym opcode is a mono version of sfplay. It should be used with
mono preset, or with the stereo presets in which stereo output is not
required, because is a bit faster than sfplay.

sfinstr plays an SF2 instrument instead of a preset (an SF2 instrument
is the base of a preset layer). instrnum argument contains the
instrument number, and the user must be sure that such number belongs
to an existent instrument of a determinate soundfont bank. Notice that
both xamp and xfreq arguments can contain k-rate signals as well as
a-rate signals, but, also in this case, the user must be sure that
both arguments are filled with variables of the same rate, or sfinstr
will not work correctly.

sfinstrm plays is a mono version of sfinstr. This is the fastest
opcode of the SF2 family. 

These Csound opcodes only handle sampling structure of SF2 files,
because support of modulator objects (amplitude envelopes,
frequency modulation, filter envelopes and modulation) is very basic
and trivial in SF2 standard; so, adding any kind of modulation or
processing to the sample data is completely left to the Csound user,
bypassing all restrictions forced by the SF2 standard.

Gabriel Maldonado
------------------------------------------------------------------------
		scanu	iinit, irate, ivel,
			im, if, ic, id, km, kf, kc, kd,
			il, ir, kx, ky, ain, idisp, iid

iinit: the initial position of the masses.  If this is a negative
number, then the absolute of iinit signifies the table to use as a
hammer shape.  If iinit > 0, the length of it should be the same as
the intended mass number, otherwise it can be anything.

irate: the amount of time between successive updates of the mass
state.  Kind of like the sample period of the system.  If the number
is big the string will update at a slow rate showing little timbral
variability, otherwise it will change rapidly resulting in a more
dynamic sound.

ivel: The number of the ftable that contains the initial velocity for
each mass.  It should have the same size as the indented mass number.

im: The number of the ftable that contains the mass of each mass.  It
should have the same size as the indented mass number.

if: The number of the ftable that contains the spring stiffness of
each connection.  It should have the same size as the square of the
indented mass number.  The data ordering is a row after row dump of
the connection matrix of the system.

ic: The number of the ftable that contains the centering force of each
mass.  It should have the same size as the indented mass number.

id: The number of the ftable that contains the damping factor of each
mass.  It should have the same size as the indented mass number.

km: A parameter that scales the masses.

kf: a parameter that scales the spring stiffness.

kc; a parameter that scales the centering force.

kd: a parameter that scales damping.

il: If iinit < 0, the position of the left hammer (il = 0 is hit at 
leftmost, il = 1 is hit at rightmost).

ir: If iinit < 0, the position of the right hammer (ir = 0 is hit at 
leftmost, ir = 1 is hit at rightmost).

ix: This is the position of an active hammer along the string (0 
leftmost,1 rightmost).  The shape of the
hammer is determined by iinit and the power it pushes with is iy.

iy: The power that the active hammer uses.

ain:  The audio input that adds to the velocity of the masses (don't 
make it too loud).

idisp: If 0, no display of the masses is provided.  Otherwise you get 
to see them wiggle.

iid: For scanu: the ID of the opcode.  This will be used to point the
scanning opcode to the proper waveform maker.  If this value is
negative it is minus the wavetable on which to write the waveshape.
That wavetable can be used later from an other opcode to generate
sound.  The initial contents of this table will be destroyed, so do
not rely on them being there.


The syntax for scans is:

		scans	kamp, kfreq, itrj, iid

kamp: The output amplitude.  Note that the resulting amplitude is also
dependent to the state of the wavetable.  This number is effectively
the scaling factor of the wavetable.

kfreq: The frequency of the scan rate.

itraj: The number of the ftable that contains the scanning trajectory.
This is a series of numbers that contains addresses of masses.  The
order of these addresses is used as the scan path.  It shouldn't
contain values more that the number of masses, as well as negative
numbers.

iid: The ID number of the scanu opcode's waveform to use.  To produce
the matrices, the file format is straightforward. For example for 4
masses we have the following grid describing the connections:


   | 1 | 2 | 3 | 4 |
-------------------
1 |   |   |   |   |
-------------------
2 |   |   |   |   |
-------------------
3 |   |   |   |   |
-------------------
4 |   |   |   |   |
-------------------

Whenever two masses are connected then the point they define is 1, so for
a unidirectional string we would have the following connections, (1,2),
(2,3), (3,4) (if it was bidirectional we would also have (2,1), (3,2),
(4,3)).  So I fill these out with ones and the rest with zeros and I get:

  | 1 | 2 | 3 | 4 |
-------------------
1 | 0 | 1 | 0 | 0 |
-------------------
2 | 0 | 0 | 1 | 0 |
-------------------
3 | 0 | 0 | 0 | 1 |
-------------------
4 | 0 | 0 | 0 | 0 |
-------------------

Similarly for the other shapes, I find the connections and fill them
out.  This gets saved in an ASCII file column by column, so the string up
there would be saved as:

0.
1.
0.
0.
0.
0.
1.
0.
0.
0.
0.
1.
0.
0.
0.
0.

Paris Smaragdis
------------------------------------------------------------------------

