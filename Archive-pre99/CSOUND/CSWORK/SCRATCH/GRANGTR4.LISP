(in-package :stella) (defparameter *totaldur* 0)(defparameter i 0)(defparameter du 0)(defparameter idx 0)(defparameter idur 0) (defparameter idxdur 0) (defparameter overalltempo 0) ; (defobject soundin (csound-note)   ((instr :initform "i1") inst dur idx pan dist pct pitch amp)   (:parameters instr time dur idx pan dist pct pitch amp))(defobject soundwarp (csound-note)  ((instr :initform "i2") dur amp pitch pan dist pct istr iendx indx iatck)  (:parameters instr time dur amp pitch pan dist pct istr iendx indx iatck))(defobject revnote (csound-note)  ((name :initform "i99") mystart dur revtime)  (:parameters name mystart dur revtime));(defun loop1 (st len pn tem am rot)  (algorithm nil soundin (start st length len)    (setf idxdur '((0.0  e) (.366 e.) (.885 e) (1.234 e) (1.602 e)(1.974 e) (2.287 e)(2.673 e)(3.045 e.)(3.541 q)                    (4.264 q+s)                   ))    (setf i (item (items 0 1 2 3 4 5 6 7 8 9 10 in random)))    ;11 items, for 'polvoish.aif'    (setf idur (nth i idxdur))	;pick i'th pair out of idxdur    (setf idx (nth 0 idur))		;set idx to 1st element    (setf du (nth 1 idur))		;set dur to 2nd element    (setf dur (rhythm du tem));    (setf rhythm (rhythm du tem))   (setf rhythm (item	          (items	            (items (rhythms q e e e e s s s e. e. in heap tempo (tempo tem)) for 3)	            (items (rhythms q q s e s s e s q e. e q e s in rotation		                    change (changes start '(0 1) step rot) tempo (tempo tem)) for 3);	            (items (rhythms (12 weight 5) (6 weight 3) (32 weight 2) in random tempo (tempo tem)) for 10)	            )))   (if (> dur rhythm)     (setf dur rhythm));    (setf rhythm (item (rhythms e e e. e e q;                                e e e. e s s s s s s s in heap)))        (setf pitch (* tem 0.0119));to get pitch adjustment: x times tem = pitch scalar. ;I use 1/orig. tem to get scalar    (if (= pn 100)      (setf pan (between 50 70))      (setf pan pn))    (setf dist 10)    (setf pct .01)    (setf amp am)    (setf *totaldur* (max (+ time dur) *totaldur*))));;  (:parameters instr time dur amp pitch pan dist pct istr iendx indx iatck));(defun loop2 (st len pn tem am rot)  (algorithm nil soundwarp (start st length len)    (setf idxdur '((0.0  e) (.366 e.) (.885 e) (1.234 e) (1.602 e)(1.974 e) (2.287 e)(2.673 e)(3.045 e.)(3.541 q)                    (4.264 q+s)                   ))    (setf i (item (items 0 1 2 3 4 5 6 7 8 9 10 in heap)))    (setf idur (nth i idxdur))	;pick i'th pair out of idxdur    (setf idx (nth 0 idur))		;set idx to 1st element    (setf du (nth 1 idur))		;set dur to 2nd element    (setf dur (rhythm du tem))    (setf rhythm (rhythm du tem))    (setf pitch 1)    (if (= pn 100)      (setf pan (between 50 70))      (setf pan pn))    (setf dist 10)    (setf pct .01)    (setf amp am)    (setf indx idx)    (setf iendx (+ indx (rhythm du 84)))    (setf iatck .01)    (setf istr 1)    (setf *totaldur* (max (+ time dur) *totaldur*))));;(defun loop3 (st len pn tem am rot)  (algorithm nil soundin (start st length len)    (setf idxdur '((0.0  e) (.366 e.) (.885 e) (1.234 e) (1.602 e)(1.974 e) (2.287 e)(2.673 e)(3.045 e.)(3.541 q)                    (4.264 q+s)                   ))    (setf i (item (items                    (items 7 for 10)                    (items 3 7 in heap for 10)                    (items 3 4 5 7 in heap for 10)                    (items 3 4 5 7 0 2 in heap for 10)                    (items 0 1 2 3 4 5 6 7 8 9 10 in heap for 10)                    in palindrome)))                        (setf idur (nth i idxdur))	;pick i'th pair out of idxdur    (setf idx (nth 0 idur))		;set idx to 1st element    (setf du (nth 1 idur))		;set dur to 2nd element;1)tempo increases over time, and dur increases    (setf tempofinal (interpl count 0 tem (* len .5) (* tem 1.2) len tem))    (setf dur (* (rhythm du tempofinal) (interpl count 0 1.0 len 2)));2)something is tied to amp value;3)number of sounds grows from one section of source to many;4)methods change: starts as soundin, grows to include pvoc, sndwarp?    (setf rhythm (rhythm du tempofinal))    (setf pitch (* tempofinal 0.0119));to get pitch adjustment: x times tem = pitch scalar. ;I use 1/orig. tem to get scalar    (if (= pn 100)      (setf pan (between 20 70))      (setf pan pn))    (setf dist 10)    (setf pct .01)    (setf amp am)    (setf *totaldur* (max (+ time dur) *totaldur*))));;(defun loop4 (st len pn tem am rot)  (algorithm nil soundwarp (start st length len)    (setf idxdur '((0.0  e) (.366 e.) (.885 e) (1.234 e) (1.602 e)(1.974 e) (2.287 e)(2.673 e)(3.045 e.)(3.541 q)                    (4.264 q+s)                   ));    (setf i (item (items 0 1 2 3 4 5 6 7 8 9 10 in heap)))    (setf i (item (items                    (items 7 for 10)                    (items 3 7 in random for 10)                    (items 3 4 5 7 in heap for 10)                    (items 3 4 5 7 0 2 in heap for 10)                    (items 0 1 2 3 4 5 6 7 8 9 10 in heap for 10)                    in palindrome)))                        (setf idur (nth i idxdur))	;pick i'th pair out of idxdur    (setf idx (nth 0 idur))		;set idx to 1st element    (setf du (nth 1 idur))		;set dur to 2nd element;1)tempo increases over time, and dur increases    (setf tempofinal (interpl count 0 tem (* len .5) (* tem 1.5) len tem))    (setf dur (* (rhythm du tempofinal) (interpl count 0 1.0 len 10)));2)something is tied to amp value;3)number of sounds grows from one section of source to many;4)methods change: starts as soundin, grows to include pvoc, sndwarp?    (setf rhythm (rhythm du tempofinal))    (setf pitch (between .999 1.001))    (if (= pn 100)      (setf pan (between 30 70))      (setf pan pn))    (setf dist 10)    (setf pct .01)    (setf amp (between 1 am))    (setf indx idx)    (setf iendx (+ indx (rhythm du 84)))    (setf iatck .01)    (setf istr 1)    (setf *totaldur* (max (+ time dur) *totaldur*))));;(defun mrn (&key (revtime 5.))  (algorithm nil revnote (start 10000 length 1 revtime revtime rhythm 0)	     (setf mystart 0)	     (setf dur (+ revtime *totaldur* 1))	     )) ; (defun ms (&key (start-time 1.)(my-scorefile "grangtr1.sco"))   (let* ((myheader (header ""                     "f 1 0 1048576 1 \"polvoish.aif\" 0 0 0"                    "f 8 0 16384 9 .5 1 0"			   )))    (fheader my-scorefile myheader)     (merge all () ;;function proto:;          (st len pn tem am rot/pitch);      (loop4 1 400 10 200 .5 1)      (loop4 1 400 80 200 .5 1);      (loop3 22 150 10 80 .7 1.02);      (loop3 22 150 80 80 .7 1);      (loop3 22 150 30 80 .8 1.02);      (loop3 22 150 60 80 .8 1);      (loop2 78.57 150 0 120 1 5);      (loop2 78.57 150 90 120 1 5)      (mrn)            )    (open-cmd my-scorefile) 	(mix-cmd "all")))