;
; ""
; by 
;
; -B value and DMA buffer setting must be equal!
;
; Generated by blue 0.104.3 (http://csounds.com/stevenyi/blue/index.html)
;

<CsoundSynthesizer>

<CsInstruments>
sr=44100
kr=44100
;ksmps=1
nchnls=1


;minimal global vars - from old UI

;***********************************************************
;	THIS IS THE MAXIMUM DELAY TIME
;***********************************************************
#define	totalDelayLineTime	#32#
;***********************************************************
;	THIS IS THE IO Base channel - stereo output 
;	goes in and out from IOBaseChannel and 
;	IOBaseChannel+1
;***********************************************************
#define	IOBaseChannel	#1#

gkmaxdel	init $totalDelayLineTime
gidelsize init i(gkmaxdel)
gicrossfadetime init .05

gkcrossfade_before_1 init 0
gkcrossfade_after_1 init 0
gafadein_1 init 0
gafadeout_1 init 1
gkchange_1 init 0

gasig	init 0
gaout1	init 0
gaout2	init 0
gaout1_1	init 0





gkinput_1 init 1	; input volume
gkoutput_1 init 1	; output volume

gkloop_1 init 1 	; input on/off
gkloopread_1 init 1 	; output on/off

garegensig1_1 init 0	; regenerated signal - added to delay output * regen setting 
gkregen_1 init .8 	; regenerated signal scalar (see garegensig1_1)


gkrate_in_1_temp init 1	; delay point in line - update w/osc 


gihandle OSCinit 8000

	instr 1	;track 1
icrossinstr = 101

ainputsig = 0

kosc_delaytime init 0
kosc_regentime init 0
kosc_input_on init 0
kosc_output_on init 0
kosc_involume init 0
kosc_outvolume init 0

k1  OSClisten gihandle, "/1/fader1", "f", kosc_delaytime
k2  OSClisten gihandle, "/1/rotary1", "f", kosc_regentime
k3  OSClisten gihandle, "/1/toggle1", "f", kosc_input_on
k4  OSClisten gihandle, "/1/toggle2", "f", kosc_output_on
k5  OSClisten gihandle, "/1/rotary2", "f", kosc_involume
k6  OSClisten gihandle, "/1/rotary3", "f", kosc_outvolume
if (k1 == 0) goto osc_2
	printks "kosc_delaytime: %f \n", .1, kosc_delaytime
gkrate_in_1_temp = kosc_delaytime * gkmaxdel
osc_2:
if (k2 == 0) goto osc_3
	printks "kosc_regentime: %f \n", .1, kosc_regentime
gkregen_1 = kosc_regentime
osc_3:
if (k3 == 0) goto osc_4
	printks "kosc_input_on: %f \n", .1, kosc_input_on
gkloop_1 = kosc_input_on
osc_4:
if (k4 == 0) goto osc_5
	printks "kosc_output_on: %f \n", .1, kosc_output_on
gkloopread_1 = kosc_output_on
osc_5:
if (k5 == 0) goto osc_6
	printks "kosc_involume: %f \n", .1, kosc_involume
gkinput_1 = kosc_involume
osc_6:
if (k6 == 0) goto osc_done
	printks "kosc_outvolume: %f \n", .1, kosc_outvolume
gkoutput_1 = kosc_outvolume
osc_done:

if	gkloop_1 = 0 kgoto noread

kchan = $IOBaseChannel
kchanout = $IOBaseChannel

ainputsig 		inch kchan
ainputsig = ainputsig * gkinput_1

noread:

;if (gkcrossfade_before_1 = 0) then
;    gkcrossfade_before_1 = gkrate_in_1
;    gkcrossfade_after_1 = gkrate_in_1
;endif


asig = ainputsig +  (garegensig1_1 * gkregen_1)


;printk .1, gkchange_1

kactive active k(icrossinstr)
;if kactive > 0 then
printk .1, kactive
;	printks "setting\n", .01
;	FLsetVal	1, gkcrossfade_after_1, gihtap1
;	gkrate_in_1 = gkcrossfade_after_1
;endif

; so - you're basically trying to get the thing to ignore the ui when change is 
; in progress, but it ain't workin so far...
if  ((gkcrossfade_before_1 != gkrate_in_1_temp && kactive == 0.0) || kactive > 0) then
	printks "checking....", .01
	if (gkchange_1 == 1 && kactive == 0.0) then
		printks "event is ended\n", .01
        gkchange_1 = 0
        gafadein_1 = 1.0
        gafadeout_1 = 0
        gkcrossfade_before_1 = gkcrossfade_after_1
    elseif (gkchange_1 == 1 && kactive > 0) then
		printks "crossfading, keeping state....\n", .01
		; don't update the tap time until we're done x-fading
		;gkrate_in_1_temp = gkcrossfade_before_1
    elseif (gkchange_1 == 0) then
		printks "starting event....\n", .01
        gkcrossfade_after_1 = gkrate_in_1_temp
        gkchange_1 = 1
        gafadein_1 = 0
        gafadeout_1 = 1.0
        event "i", icrossinstr, 0, gicrossfadetime
    endif

endif

aout_total   delayr     gidelsize
aoutnew   deltapi     gkcrossfade_after_1
aoutold   deltapi     gkcrossfade_before_1
delayw      asig
aout = (aoutnew * gafadein_1) + (aoutold * gafadeout_1)

;
;	send out to regensig's for optional addition if sus pedal is pressed
;
garegensig1_1 = aout
readquery:
if 	gkloopread_1 = 0	kgoto off

read:
out	aout*gkoutput_1
gaout1_1 = aout
kgoto out
off:
;turnoffk	gkturnoff
gaout1_1 = 0
out:

	endin



    instr 101
gafadein_1   linseg    0.0, p3, 1.0
gafadeout_1   linseg   1.0, p3, 0.0
    endin



</CsInstruments>

<CsScore>
i1 0 3600

e

</CsScore>

</CsoundSynthesizer>
